package com.github.panpf.zoomimage.core

import com.github.panpf.zoomimage.core.internal.format
import com.github.panpf.zoomimage.core.internal.lerp
import kotlin.math.roundToInt

/**
 * Holds 2 dimensional scaling factors for horizontal and vertical axes
 */
data class ScaleFactorCompat(
    /**
     * Returns the scale factor to apply along the horizontal axis
     */
    val scaleX: Float,
    /**
     * Returns the scale factor to apply along the vertical axis
     */
    val scaleY: Float
) {

    /**
     * Multiplication operator.
     *
     * Returns a [ScaleFactorCompat] with scale x and y values multiplied by the operand
     */
    operator fun times(operand: Float) = ScaleFactorCompat(scaleX * operand, scaleY * operand)

    /**
     * Division operator.
     *
     * Returns a [ScaleFactorCompat] with scale x and y values divided by the operand
     */
    operator fun div(operand: Float) = ScaleFactorCompat(scaleX / operand, scaleY / operand)

    override fun toString() = "ScaleFactor(${scaleX.format(2)}, ${scaleY.format(2)})"

    companion object {

        /**
         * A ScaleFactor whose [scaleX] and [scaleY] parameters are unspecified. This is a sentinel
         * value used to initialize a non-null parameter.
         * Access to scaleX or scaleY on an unspecified size is not allowed
         */
        val Unspecified = ScaleFactorCompat(scaleX = Float.NaN, scaleY = Float.NaN)

        val Origin = ScaleFactorCompat(scaleX = 1f, scaleY = 1f)
    }
}

/**
 * `false` when this is [ScaleFactorCompat.Unspecified].
 */
inline val ScaleFactorCompat.isSpecified: Boolean
    get() = !scaleX.isNaN() && !scaleY.isNaN()

/**
 * `true` when this is [ScaleFactorCompat.Unspecified].
 */
inline val ScaleFactorCompat.isUnspecified: Boolean
    get() = scaleX.isNaN() || scaleY.isNaN()

/**
 * If this [ScaleFactorCompat] [isSpecified] then this is returned, otherwise [block] is executed
 * and its result is returned.
 */
inline fun ScaleFactorCompat.takeOrElse(block: () -> ScaleFactorCompat): ScaleFactorCompat =
    if (isSpecified) this else block()

operator fun ScaleFactorCompat.times(scaleFactor: ScaleFactorCompat) =
    ScaleFactorCompat(scaleX * scaleFactor.scaleX, scaleY * scaleFactor.scaleY)

operator fun ScaleFactorCompat.div(scaleFactor: ScaleFactorCompat) =
    ScaleFactorCompat(scaleX / scaleFactor.scaleX, scaleY / scaleFactor.scaleY)

/**
 * Multiplication operator with [IntSizeCompat].
 *
 * Return a new [IntSizeCompat] with the width and height multiplied by the [ScaleFactorCompat.scaleX] and
 * [ScaleFactorCompat.scaleY] respectively
 */
operator fun IntSizeCompat.times(scaleFactor: ScaleFactorCompat): IntSizeCompat =
    IntSizeCompat(
        (this.width * scaleFactor.scaleX).roundToInt(),
        (this.height * scaleFactor.scaleY).roundToInt()
    )

/**
 * Multiplication operator with [IntSizeCompat] with reverse parameter types to maintain
 * commutative properties of multiplication
 *
 * Return a new [IntSizeCompat] with the width and height multiplied by the [ScaleFactorCompat.scaleX] and
 * [ScaleFactorCompat.scaleY] respectively
 */
operator fun ScaleFactorCompat.times(size: IntSizeCompat): IntSizeCompat = size * this

/**
 * Division operator with [IntSizeCompat]
 *
 * Return a new [IntSizeCompat] with the width and height divided by [ScaleFactorCompat.scaleX] and
 * [ScaleFactorCompat.scaleY] respectively
 */
operator fun IntSizeCompat.div(scaleFactor: ScaleFactorCompat): IntSizeCompat =
    IntSizeCompat(
        (width / scaleFactor.scaleX).roundToInt(),
        (height / scaleFactor.scaleY).roundToInt()
    )

/**
 * Linearly interpolate between two [ScaleFactorCompat] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(start: ScaleFactorCompat, stop: ScaleFactorCompat, fraction: Float): ScaleFactorCompat {
    return ScaleFactorCompat(
        lerp(start.scaleX, stop.scaleX, fraction),
        lerp(start.scaleY, stop.scaleY, fraction)
    )
}


fun ScaleFactorCompat.toShortString(): String = "${scaleX.format(2)}x${scaleY.format(2)}"

fun ScaleFactorCompat(scale: Float): ScaleFactorCompat = ScaleFactorCompat(scale, scale)