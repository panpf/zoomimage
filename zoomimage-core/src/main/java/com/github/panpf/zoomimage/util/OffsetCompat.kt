package com.github.panpf.zoomimage.util

import com.github.panpf.zoomimage.util.internal.format
import com.github.panpf.zoomimage.util.internal.lerp
import kotlin.math.sqrt

data class OffsetCompat(
    val x: Float,
    val y: Float
) {

    companion object {
        val Zero = OffsetCompat(x = 0f, y = 0f)
        val Infinite = OffsetCompat(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY)
    }


    /**
     * The magnitude of the offset.
     *
     * If you need this value to compare it to another [OffsetCompat]'s distance,
     * consider using [getDistanceSquared] instead, since it is cheaper to compute.
     */
    fun getDistance() = sqrt(x * x + y * y)

    /**
     * The square of the magnitude of the offset.
     *
     * This is cheaper than computing the [getDistance] itself.
     */
    fun getDistanceSquared() = x * x + y * y

    /**
     * Unary negation operator.
     *
     * Returns an offset with the coordinates negated.
     *
     * If the [OffsetCompat] represents an arrow on a plane, this operator returns the
     * same arrow but pointing in the reverse direction.
     */
    operator fun unaryMinus(): OffsetCompat = OffsetCompat(-x, -y)

    /**
     * Binary subtraction operator.
     *
     * Returns an offset whose [x] value is the left-hand-side operand's [x]
     * minus the right-hand-side operand's [x] and whose [y] value is the
     * left-hand-side operand's [y] minus the right-hand-side operand's [y].
     */
    operator fun minus(other: OffsetCompat): OffsetCompat = OffsetCompat(x - other.x, y - other.y)

    /**
     * Binary addition operator.
     *
     * Returns an offset whose [x] value is the sum of the [x] values of the
     * two operands, and whose [y] value is the sum of the [y] values of the
     * two operands.
     */
    operator fun plus(other: OffsetCompat): OffsetCompat = OffsetCompat(x + other.x, y + other.y)

    /**
     * Multiplication operator.
     *
     * Returns an offset whose coordinates are the coordinates of the
     * left-hand-side operand (an OffsetCompat) multiplied by the scalar
     * right-hand-side operand (a Float).
     */
    operator fun times(operand: Float): OffsetCompat = OffsetCompat(x * operand, y * operand)

    /**
     * Division operator.
     *
     * Returns an offset whose coordinates are the coordinates of the
     * left-hand-side operand (an OffsetCompat) divided by the scalar right-hand-side
     * operand (a Float).
     */
    operator fun div(operand: Float): OffsetCompat = OffsetCompat(x / operand, y / operand)

    /**
     * Modulo (remainder) operator.
     *
     * Returns an offset whose coordinates are the remainder of dividing the
     * coordinates of the left-hand-side operand (an OffsetCompat) by the scalar
     * right-hand-side operand (a Float).
     */
    operator fun rem(operand: Float) = OffsetCompat(x % operand, y % operand)

    override fun toString() = "OffsetCompat(${x.format(2)}x${y.format(2)})"
}

/**
 * Linearly interpolate between two [OffsetCompat] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(start: OffsetCompat, stop: OffsetCompat, fraction: Float): OffsetCompat {
    return OffsetCompat(
        lerp(start.x, stop.x, fraction),
        lerp(start.y, stop.y, fraction)
    )
}

/**
 * True if both x and y values of the [OffsetCompat] are finite
 */
val OffsetCompat.isFinite: Boolean get() = x.isFinite() && y.isFinite()


fun OffsetCompat.toShortString(): String = "${x.format(2)}x${y.format(2)}"

operator fun OffsetCompat.times(scaleFactor: ScaleFactorCompat): OffsetCompat {
    return OffsetCompat(x = x * scaleFactor.scaleX, y = y * scaleFactor.scaleY)
}

operator fun OffsetCompat.div(scaleFactor: ScaleFactorCompat): OffsetCompat {
    return OffsetCompat(x = x / scaleFactor.scaleX, y = y / scaleFactor.scaleY)
}